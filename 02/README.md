# 데이터 다루기
[01] 훈련 세트와 테스트 세트
---
### 01. 지도 학습과 비지도 학습
#### 지도 학습(supervised learning)
- 지도 학습 알고리즘 : 훈련하기 위한 데이터와 정답 필요

  - ex. k-최근접 이웃 알고리즘

  - **훈련 데이터**(training data) = **입력**(input, 데이터) + **타깃**(target, 정답)
 
- 정답(타깃)이 있으니 알고리즘이 정답을 맞히는 것을 학습

  - ex. 도미인지 빙어인지 구분

<br>

#### 비지도 학습(unsupervised learning)
- 비지도 학습 알고리즘 : 타깃 없이 입력 데이터만 사용

- 정답을 사용하지 않으므로 무언가를 맞힐 수 없음

- 데이터 파악 또는 변형에 도움

<br>

#### 강화 학습(reinforcement learning)
- 강화 학습 알고리즘 : 타깃이 아니라 알고리즘이 행동한 결과로 얻은 보상을 사용해 학습됨

<br>

### 02. 훈련 세트와 테스트 세트
- 머신러닝 알고르짐의 성능을 제대로 평가하려면 훈련 데이터와 평가에 사용할 데이터가 각각 달라야 함

  - 평가를 위해 또 다른 데이터를 준비
 
  - 이미 준비된 데이터 중에서 일부를 떼어 내어 활용 (일반적으로 많이 사용)
 
<BR>

#### 테스트 세트(test set)
- 평가에 사용하는 데이터

<br>

#### 훈련 세트(train set)
- 훈련에 사용되는 데이터

<br>

> 도미와 빙어의 데이터를 합쳐 하나의 파이썬 리스트로 준비
```python
  fish_length = [25.4, 26.3, 26.5, 29.0, 29.0, 29.7, 29.7, 30.0, 30.0, 30.7, 
                  31.0, 31.0, 31.5, 32.0, 32.0, 32.0, 33.0, 33.0, 33.5, 33.5,
                  34.0, 34.0, 34.5, 35.0, 35.0, 35.0, 35.0, 36.0, 36.0, 37.0,
                  38.5, 38.5, 39.5, 41.0, 41.0, 9.8, 10.5, 10.6, 11.0, 11.2, 
                  11.3, 11.8, 11.8, 12.0, 12.2, 12.4, 13.0, 14.3, 15.0]
  fish_weight = [242.0, 290.0, 340.0, 363.0, 430.0, 450.0, 500.0, 390.0,
                  450.0, 500.0, 475.0, 500.0, 500.0, 340.0, 600.0, 600.0,
                  700.0, 700.0, 610.0, 650.0, 575.0, 685.0, 620.0, 680.0,
                  700.0, 725.0, 720.0, 714.0, 850.0, 1000.0, 920.0, 955.0,
                  925.0, 975.0, 950.0, 6.7, 7.5, 7.0, 9.7, 9.8, 8.7, 10.0, 
                  9.9, 9.8, 12.2, 13.4, 12.2, 19.7, 19.9]
```

> 두 파이썬 리스트를 순회하면서 각 생선의 길이와 무게를 하나의 리스트로 담은 2차원 리스트 생성
```python
  fish_data = [[l, w] for l, w in zip(fish_length, fish_weight)]
  fish_target = [1] * 35 + [0] * 14
```
- 하나의 생선 데이터를 **샘플**이라 부름

  - 도미와 빙어는 각각 35마리, 14마리가 있으므로 전체 데이터는 49개의 샘플로 이루어져 있음
 
- 사용하는 특성은 2개 (길이, 무게)

<br>

<details>
  <summary>💡 인덱스 지정 및 슬라이싱</summary>

<br>

> 코드
```python
  # 인덱스 지정
  print(fish_data[4], '\n')
  
  # 슬라이싱
  print(fish_data[0:5])
  print(fish_data[:5])
  print(fish_data[44:49])
  print(fish_data[44:])
```
- 리스트처럼 배열의 요소를 선택할 때는 배열의 위치(**인덱스**, index) 지정

  - 배열의 인덱스는 0부터 시작 → 다섯 번째 샘플의 인덱스 = 4
 
- **슬라이싱**(slicing) : 콜론(:)을 가운데 두고 인덱스의 범위를 지정하여 여러 개의 원소 선택 가능

  - **마지막 인덱스의 원소는 포함되지 않는다**는 점 주의
 
    - ex. '0:5' ⇒ 0~4 까지의 5개 원소만 선택되고 인덱스 5인 여섯 번째 원소는 선택 X
   
      - 처음부터 시작되는 슬라이싱의 경우 0 생략 가능
     
    - ex. '44:49' ⇒ '44:' 로 사용 가능
     
      - 마지막 원소까지 포함할 경우 두 번재 인덱스 생략 가능

<br>

> 결과
```python
  [29.0, 430.0] 
  
  [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0]]
  [[25.4, 242.0], [26.3, 290.0], [26.5, 340.0], [29.0, 363.0], [29.0, 430.0]]
  [[12.2, 12.2], [12.4, 13.4], [13.0, 12.2], [14.3, 19.7], [15.0, 19.9]]
  [[12.2, 12.2], [12.4, 13.4], [13.0, 12.2], [14.3, 19.7], [15.0, 19.9]]
```

</details>

<br>

> 처음 35개를 훈련 세트로, 나머지 14개를 테스트 세트로 사용
```python
  from sklearn.neighbors import KNeighborsClassifier
  kn = KNeighborsClassifier()
  
  # 훈련 세트로 입력값 중 0부터 34번째 인덱스까지 사용
  train_input = fish_data[:35]
  # 훈련 세트로 타깃값 중 0부터 34번째 인덱스까지 사용
  train_target = fish_target[:35]
  # 테스트 세트로 입력값 중 35번째부터 마지막 인덱스까지 사용
  test_input = fish_data[35:]
  # 테스트 세트로 타깃값 중 35번째부터 마지막 인덱스까지 사용
  test_target = fish_target[35:]
  
  kn.fit(train_input, train_target)
  kn.score(test_input, test_target)
```
-  슬라이싱 연산으로 인덱스 0\~34 까지 처음 35개 샘플을 훈련 세트로 선택, 인덱스 35\~48 까지 나머지 14개 샘플을 테스트 세트로 선택

-  데이터 준비 후 훈련 세트로 fit() 메서드를 호출해 모델 훈련 후 테스트 세트로, score() 메서트를 호출해 평가

> 결과
```python
  0.0
```
- 최악의 성능 why?

  - fish_data 에 순서대로 35개의 도미와 14개의 빙어 샘플이 들어있음
 
    - 마지막 14개를 테스트 세트로 만들면 빙어 데이터만 들어감
   
    - 훈련 세트에는 도미만 있기 때문에 테스트 세트가 무엇이든 무조건 도미라고 분류하므로 정답 맞히지 못함
   
- 훈련 데이터와 테스트 데이터에는 도미와 빙어가 골고루 섞여 있어야 함

<br>

### 03. 샘플링 편향(sampling bias)
- 훈련 세트와 테스트 세트에 샘플이 골고루 섞여 있지 않으면 샘플링이 한쪽으로 치우친 상태

- 특정 종류의 샘플이 과도하게 많은 샘플링 편향을 가지고 있다면 제대로 된 지도 학습 모델을 만들 수 없음

<br>

### 04. 넘파이(numpy)
- 파이썬의 대표적인 배열(array) 라이브러리

- 고차원의 배열을 손쉽게 만들고 조작할 수 있는 간편한 도구 많이 제공

  - 파이썬의 리스트로 2차원 리스트는 표현 가능하지만 고차원 리스트 표현은 번거로움

  - 차원(dimension)이란 말은 조금씩 다른 의미로 쓰일 수 있으나 배열에서 차원은 좌표계의 축과 같음

|1차원 배열|2차원 배열|3차원 배열|
|:-:|:-:|:-:|
|![이미지](./img/01.png)|![이미지](./img/02.png)|![이미지](./img/03.png)|
|선|면|공간|

- 배열의 시작점이 왼쪽 위에서부터 시작함

<br>

> 생선 데이터를 2차원 넘파이 배열로 변환
```python
  import numpy as np
  
  input_arr = np.array(fish_data)
  target_arr = np.array(fish_target)
  
  print(input_arr)
  print(input_arr.shape)  # (샘플 수, 특성 수) 출력
```
- 파이썬 리스트를 넘파이 배열로 바꾸는 방법

  - 넘파이 array() 함수에 파이썬 리스트를 전달
 
- shape 속성 : 배열의 크기 확인

> 결과
```python
  [[  25.4  242. ]
   [  26.3  290. ]
    ...
   [  15.    19.9]]
  (49, 2)
```
- 넘파이는 배열의 차원을 구분하기 쉽도록 행과 열을 가지런히 출력

  - 49개의 행과 2개의 열 확인 가능
 
<br>

---

<br>

[2] 데이터 전처리
---

<br>
